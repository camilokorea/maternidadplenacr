<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <title>Calculadora de Gestaci√≥n</title>
    <script src="https://cdn.jsdelivr.net/npm/konva@9.2.0/konva.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #fefefe;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #container {
            width: 100%;
            border: 1px solid red;
        }
    </style>
</head>

<body>
    <div id="container"></div>

    <script>
        Konva.angleDeg = false;
        let angularVelocity = 6;
        const angularVelocities = [];
        let lastRotation = 0;
        let controlled = false;
        const numWedges = 40;
        const angularFriction = 0.2;
        let target, activeWedge, stage, layer, wheel, pointer;
        let finished = false;

        function getAverageAngularVelocity() {
            const total = angularVelocities.reduce((sum, vel) => sum + vel, 0);
            return angularVelocities.length ? total / angularVelocities.length : 0;
        }

        function purifyColor(color) {
            const randIndex = Math.round(Math.random() * 10);
            color[randIndex] = 0;
            return color;
        }

        function getRandomColor() {
            const palette = [
                [241, 194, 204],  // Rosa claro
                [173, 216, 230],  // Celeste pastel
                [202, 191, 255],  // Lila suave
                [250, 250, 250],  // Blanco roto
                [220, 220, 220]   // Gris suave
            ];
            const randomIndex = Math.floor(Math.random() * palette.length);
            return palette[randomIndex];
        }

        function getRandomReward() {
            const mainDigit = Math.round(Math.random() * 9);
            return mainDigit + '\n0\n0';
        }

        function addWedge(n) {
            const s = getRandomColor();
            // const reward = getRandomReward();
            const reward = n + 1;
            const [r, g, b] = s;
            const angle = (2 * Math.PI) / numWedges;

            const endColor = `rgb(${r},${g},${b})`;
            const startColor = `rgb(${r + 100},${g + 100},${b + 100})`;

            const wedge = new Konva.Group({
                rotation: (2 * n * Math.PI) / numWedges,
            });

            const wedgeBackground = new Konva.Wedge({
                radius: 350,
                angle: angle,
                fillRadialGradientStartPoint: 0,
                fillRadialGradientStartRadius: 0,
                fillRadialGradientEndPoint: 0,
                fillRadialGradientEndRadius: 400,
                fillRadialGradientColorStops: [0, startColor, 1, endColor],
                fill: '#64e9f8',
                fillPriority: 'radial-gradient',
                stroke: '#ccc',
                strokeWidth: 2,
            });

            wedge.add(wedgeBackground);

            const text = new Konva.Text({
                text: reward,
                fontFamily: 'Calibri',
                fontSize: 30,
                fill: 'black',
                align: 'center',
                stroke: 'black',
                strokeWidth: 1,
                rotation: (Math.PI + angle) / 2,
                x: 330,
                y: 10,
                listening: false,
            });

            wedge.add(text);
            text.cache();

            wedge.startRotation = wedge.rotation();
            wheel.add(wedge);
        }

        function animate(frame) {
            // handle wheel spin
            const angularVelocityChange =
                (angularVelocity * frame.timeDiff * (1 - angularFriction)) / 1000;
            angularVelocity -= angularVelocityChange;

            // activate / deactivate wedges based on point intersection
            const shape = stage.getIntersection({
                x: stage.width() / 2,
                y: 100,
            });

            if (controlled) {
                if (angularVelocities.length > 10) {
                    angularVelocities.shift();
                }

                angularVelocities.push(
                    ((wheel.rotation() - lastRotation) * 1000) / frame.timeDiff
                );
            } else {
                const diff = (frame.timeDiff * angularVelocity) / 1000;
                if (diff > 0.0001) {
                    wheel.rotate(diff);
                } else if (!finished && !controlled) {
                    if (shape) {
                        const text = shape.getParent().findOne('Text').text();
                        const price = text.split('\n').join('');
                        alert('Your price is ' + price);
                    }
                    finished = true;
                }
            }
            lastRotation = wheel.rotation();

            if (shape && (!activeWedge || shape._id !== activeWedge._id)) {
                pointer.y(20);

                new Konva.Tween({
                    node: pointer,
                    duration: 0.3,
                    y: 30,
                    easing: Konva.Easings.ElasticEaseOut,
                }).play();

                if (activeWedge) {
                    activeWedge.fillPriority('radial-gradient');
                }
                shape.fillPriority('fill');
                activeWedge = shape;
            }
        }

        stage = new Konva.Stage({
            container: 'container',
            width: window.innerWidth,
            height: window.innerHeight,
        });

        layer = new Konva.Layer();
        wheel = new Konva.Group({
            x: stage.width() / 2,
            y: 410,
        });

        for (let n = 0; n < numWedges; n++) {
            addWedge(n);
        }

        pointer = new Konva.Wedge({
            fillRadialGradientStartPoint: 0,
            fillRadialGradientStartRadius: 0,
            fillRadialGradientEndPoint: 0,
            fillRadialGradientEndRadius: 30,
            fillRadialGradientColorStops: [0, 'white', 1, 'red'],
            stroke: 'white',
            strokeWidth: 2,
            lineJoin: 'round',
            angle: 1,
            radius: 30,
            x: stage.width() / 2,
            y: 33,
            rotation: -90,
            shadowColor: 'black',
            shadowOffsetX: 3,
            shadowOffsetY: 3,
            shadowBlur: 2,
            shadowOpacity: 0.5,
        });

        // add components to the stage
        layer.add(wheel);
        layer.add(pointer);
        stage.add(layer);

        // bind events
        wheel.on('mousedown touchstart', function (evt) {
            angularVelocity = 0;
            controlled = true;
            target = evt.target;
            finished = false;
        });

        stage.on('mouseup touchend', function () {
            controlled = false;
            angularVelocity = getAverageAngularVelocity() * 5;

            if (angularVelocity > 20) {
                angularVelocity = 20;
            } else if (angularVelocity < -20) {
                angularVelocity = -20;
            }

            angularVelocities.length = 0;
        });

        stage.on('mousemove touchmove', function () {
            const mousePos = stage.getPointerPosition();
            if (controlled && mousePos && target) {
                const x = mousePos.x - wheel.getX();
                const y = mousePos.y - wheel.getY();
                const atan = Math.atan(y / x);
                const rotation = x >= 0 ? atan : atan + Math.PI;

                wheel.rotation(rotation);
            }
        });

        // create animation
        const anim = new Konva.Animation(animate, layer);
        anim.start();
    </script>
</body>

</html>